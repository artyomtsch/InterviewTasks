**Задание 1.** 
Надо написать программу, в которой 6 тредов: Chandler, Joey, Monica, Phoebe, Rachel и Ross разыгрывают в
консоли сценки из ситкома. Каждый печатает свое имя и реплику.

Сценка дана в тексте такого формата: см. friends.txt

**Задание 2.**
Представим на время, что вы black hat, и у вас в распоряжении оказались данные ~30 млн. заказов некоторого сервиса
доставки еды за некоторый период 2021 и 2022 года.

Поверхностный анализ показал, что данные содержат 18 758 328 уникальных телефонов с полным именем клиента, а
средняя длина полного имени - 20 символов (латинских или кириллических).

Допустим, вы хотите развернуть веб-сервис, который позволит по номеру телефона найти полное имя клиента. Но вы не
хотите оставлять следы на диске или в базе данных - придется все держать в памяти. Но еще вы не хотите зря тратить
крипту на слишком большой сервер.

Поэтому давайте оценим, сколько памяти займут эти данные:

1) если мы хотим реализовать поиск за постоянное время, т.е. O(1)?

2) если мы хотим занять как можно меньше памяти?

Самое главное - объяснить, как вы пришли к той или иной числовой оценке.


**Пояснение к решению.**

**Вариант №1.** Не экономим. Временная сложность поиска O(1).

Для хранения уникальных записей создадим HashMap<String, String>, в которой будем хранить пары: ключ - номер телефона, значение - полное имя.

_Оценка затраченной памяти._ Для простоты возьмем 32-битную JVM. Фактически затраты складываются из 18 758 328 нод, хранящихся внутри HashMap. 

Рассмотрим, из каких полей состоит каждая нода.

• int hash

• String key

• String value

• Node prev

• Node next

Отдельно рассмотрим, из каких полей состоит объект String.

private final char value[];

private final int offset;

private final int count;

private int hash;

Массив char, на который ссылается char value[], также представляет собой отдельный объект в памяти, состоящий из char'ов размером в 2 байта.
Кроме того, мы должны учесть, что каждый объект в Java имеет заголовок из 8 байт, а также каждый объект выравнивается в памяти до размеров, кратных 8 байт.

Считаем:

• Заголовок ноды: 8 байт

• int hash: 4 байта

• String key: 4 байта + (8 байт заголовок + 4 байта char value[] + 12 байт инты) + (8 байт 
заголовок + 12 char * 2 байта + 4 байта length + 4 байта выравнивание) = 4 байта + 64 
байта

• String value: 4 байта + (8 байт заголовок + 4 байта char value[] + 12 байт инты) + (8 байт заголовок + 20 char * 2 байта + 4 байта length + 4 байта выравнивание) = 4 байта + 80 байт

• Node prev: 4 байта

• Node next: 4 байта

Итого: 28 байт + 4 байта выравнивание + 64 байта + 80 байт = 176 байт

Тогда итоговое количество оперативной памяти, которое нам понадобится, примерно равно: 

18 758 328 * 176 байт ≈ **3,301 ГБ**

Много, но не критично. Запустится на мощном домашнем компьютере.


**Вариант №2.** Сэкономим. Временная сложность поиска O(1).

`Идея 1`. Хранить телефонные номера в int. Таким образом, вместо 64 байт, будет использоваться 16 байт (размер объекта Integer). 
Int вмещает максимальное десятизначное положительное число 214_748_36_48. Поскольку сервис доставки еды принимает только российские номера, которые всегда начинаются на 
+79, мы можем отбросить +7, а оставшееся десятизначное число записать в int. Чтобы это сработало, придется вместо 9 в старшем разряде поместить 1. Этим мы добьемся корректной 
записи номеров с ведущими нулями, например +7900xxxxxxx -> 100xxxxxxx.

`Идея 2`. Разделить полное имя на фамилию, имя и отчество. Добиться ситуации, когда для каждой уникальной фамилии, каждого уникального имени и отчества создается ровно один 
объект String. Для этого в конструкторе используем три вспомогательные хэшмапы: HashMap<String,String> firstNames, middleNames, lastNames. При создании БД если фамилия, 
имя или отчество встречаются не в первый раз, то по ключу можем получить ссылку на уже созданный объект.

В 2019 году ЗАГСы России зафиксировали ~5000 уникальных имен для новорожденных. Следовательно, можно оценить количество созданных объектов с именами и отчествами в 
10 000 штук. Количество уникальных фамилий в России оценивается в 400 000 фамилий.

_Оценка затраченной памяти:_

• Заголовок ноды: 8 байт

• int hash: 4 байта

• Integer key: 8 байт заголовок + 4 байта int + 4 байта выравнивание = 16 байт

• String[] value: 4 байта ссылка + (8 байт заголовок + 4*3 байта ссылки + 4 байта length) = 4 байта + 24 байта

• Node prev: 4 байта

• Node next: 4 байта

Итого в ноде: 40 байт + 24 байта = 64 байта.

И еще 10 000 + 400 000 объектов String каждый по ~7 символов.

• Заголовок: 8 байт

• private final char value[]: 4 байта + (8 байт заголовок + 7*2 байта + 4 байта length + 6 байт выравнивание)

• private final int offset: 4 байта

• private final int count: 4 байта

• private int hash: 4 байта

Итого в объекте String: 24 байта + 32 байта = 56 байт.

Тогда итоговое количество оперативной памяти, которое нам понадобится, примерно равно: 
18 758 328 * 64 байта + 410 000 * 56 байт ≈ **1,223 ГБ**

Уменьшили затраты в 2.7 раза.

**Вариант №3.** Экономный. Временная сложность поиска O(log(n)).

Телефонный номер будем хранить в виде числа, фио разбиваем на части. Полный набор клиентов будем хранить в массиве объектов класса Record. Класс Record 
имеет конструктор и четыре поля - int phoneNumber, String firstName, middleName, lastName. Массив будет отсортирован по полю phoneNumber.
Благодаря сортировке, сможем использовать бинарный поиск и получать нужную запись за O(log(n)).

_Оценка затраченной памяти._

Затраченная память будет складываться из 18 758 328 объектов класса Record и 410 000 объектов класса String с ФИО клиентов.

• Заголовок: 8 байт

• int phoneNumber: 4 байта

• String firstName: 4 байта

• String middleName: 4 байта

• String lastName: 4 байта

Итого: 24 байта.
В варианте 2 уже посчитана память, которую занимают объекты String с ФИО.
Тогда итоговое количество оперативной памяти, которое нам понадобится, примерно равно: 

18 758 328 * 24 байта + 410 000 * 56 байт ≈ **473.16 МБ**

В 2.6 раза сократили затраты относительно второго способа.
