**In memory simple DB**
В процессе реализации сервиса проверки данных возникла необходимость в
организации in memory кэша с возможностью быстрого поиска по разным полям.
Структура данных представлена следующим набором полей:
{
 "account": "234678", //long
 "name": "Иванов Иван Иванович", //string
 "value": "2035.34" //double
}
Количество записей заранее не определено и может меняться динамически.
**ВОПРОС**: Необходимо организовать хранение этих записей в памяти с
соблюдением требований:
1. предоставить возможность добавлять новые записи;
2. предоставить возможность удалять более не нужные записи;
3. предоставить возможность изменять запись;
4. получать полный набор записи по любому из полей с одинаковой
алгоритмической сложностью (не медленнее log(n));
5. выбрать наиболее экономный способ хранения данных в памяти.
Важно: Нужно обосновать выбор структур данных и алгоритмов
относительно требований ТЗ.


**Пояснение к решению.**
Для хранения записей и индексов выбрана древовидная структура TreeMap, потому что 
1) в требованиях к сложности фигурировал логарифм; 
2) B-деревья используются для создания индексов в реальных базах данных. 
Хотя в целом, задание можно было сделать, используя только хэшмапы, и решение бы 
работало за О(1).
В качестве основого идентификатора записи выбрано поле account, будем считать его 
уникальным. Для поиска записи по полю account будем использовать структуру 
TreeMap<Long, Record>, где ключом будет номер аккаунта, а значением - запись базы 
данных.
Для того, чтобы искать записи по остальным двум полям, будем использовать две 
вспомогательные структуры TreeMap<String/Double, List<Long>. Так как поля name и value 
не уникальны, каждому ключу может соответствовать несколько аккаунтов. Номера 
аккаунтов будем хранить в списке в значении узла TreeMap.

Алгоритмическая сложность добавления, удаления, изменения и поиска узлов O(logn).
